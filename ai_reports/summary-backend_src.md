# Raport: Podsumowanie pliku `backend/src/main.py`

- **Czas:** 2025-04-23T13:02:00+02:00

- **Plik:** `backend/src/main.py`

- **Cel:** Główny punkt wejścia do aplikacji, który zarządza pobieraniem danych, przetwarzaniem i analizą.  Koordynuje pracę modułów analizy i przetwarzania, w tym modułu przetwarzania mediów (`media_processor.py`) oraz modułów analizy scenariuszy z katalogu `script_analysis`.  Aplikacja pobiera dane wejściowe od użytkownika (URL, ścieżki do plików), przetwarza je i generuje podsumowania za pomocą modelu językowego.  Wyniki są zapisywane do plików.  Aplikacja obsługuje przetwarzanie plików PDF, wideo i obrazów, ekstrakcję metadanych, detekcję scen i obiektów, analizę nastroju oraz generowanie tagów.  Moduł `media_processor.py` jest kluczowy dla przetwarzania plików multimedialnych, a jego wydajność ma kluczowe znaczenie dla szybkości działania całej aplikacji.  W tym module warto zwrócić uwagę na potencjalne wąskie gardła związane z przetwarzaniem wideo, które może być czasochłonne.  Nieodpowiednia obsługa błędów w module `media_processor` może prowadzić do nieoczekiwanych awarii aplikacji.  Modularizacja kodu w module `media_processor` poprawiłaby czytelność i ułatwiłaby testowanie.  Dodatkowo, brak testów jednostkowych dla modułu `media_processor` zwiększa ryzyko błędów i utrudnia testowanie.  Zależności biblioteczne w module `media_processor` powinny zostać przeanalizowane pod kątem aktualności i potencjalnych konfliktów.  W szczególności, funkcja `process_video` jest bardzo złożona i mogłaby zostać podzielona na mniejsze, bardziej modułowe funkcje, co ułatwiłoby testowanie i konserwację.  Algorytm detekcji typu ujęcia w funkcji `detect_shot_type` mógłby zostać ulepszony.  Silne sprzężenie między modułem `media_processor` a `main` utrudnia testowanie i konserwację.  Rozważenie użycia wzorców projektowych, takich jak strategia lub dekorator, mogłoby poprawić strukturę kodu i ułatwić jego rozszerzanie.

- **Kluczowe funkcje:**

  - `extract_text_from_html(html_content)`: Ekstrahuje tekst z treści HTML, usuwając tagi HTML.
  - `generate_summary(text, model_client, source_info="")`: Generuje podsumowanie tekstu za pomocą modelu językowego.
  - `crawl_website(...)`: Rekurencyjnie przegląda stronę internetową, pobiera pliki PDF i analizuje treść stron.
  - `convert_pdf_to_text(pdf_path, text_path)`: Konwertuje plik PDF do tekstu za pomocą narzędzia `pdftotext`.
  - `process_pdfs(...)`: Przetwarza listę plików PDF, ekstrahując tekst i analizując go.  Generuje podsumowanie i zapisuje je do pliku.  Dodatkowo, próbuje wyodrębnić obrazy z pliku PDF i dodać je do podsumowania w formacie PDF.
  - `process_media_file(...)`: Przetwarza pliki multimedialne (wideo lub obrazy) i generuje analizę.  Wywołuje funkcje z modułu `media_processor.py` do analizy wideo i obrazów. Generuje podsumowanie i zapisuje je do pliku.  Dodaje również wyniki analizy do systemu dokumentacji produkcji.
  - `query_production_docs(query: str) -> Dict[str, Any]`: Wykonuje zapytanie do systemu dokumentacji produkcji.
  - `main()`: Główna funkcja asynchroniczna, która zarządza przepływem pracy, pobierając dane wejściowe od użytkownika, uruchamiając odpowiednie funkcje przetwarzania i analizy oraz wyświetlając wyniki.

- **Importy:** `asyncio`, `autogen_agentchat`, `autogen_ext`, `requests`, `bs4`, `os`, `subprocess`, `textwrap`, `dotenv`, `json`, `sys`, `media_processor`, `production_docs`, `typing`, `fpdf`, `re`, `PyPDF2`, `PIL`, `io`, `fitz`.

- **Powiązania z innymi częściami projektu:**  Plik jest centralnym punktem aplikacji, silnie powiązanym z innymi modułami, takimi jak `media_processor`, `production_docs`, oraz z zewnętrznymi bibliotekami.  Moduł `media_processor` jest kluczowy dla przetwarzania plików multimedialnych.  Moduły z katalogu `script_analysis` odpowiadają za analizę tekstu.

- **Diagnostyka:**  Funkcje w `main.py` są dobrze zorganizowane i czytelne.  Jednakże, obsługa błędów mogłaby być ulepszona poprzez bardziej szczegółowe komunikaty o błędach i lepsze radzenie sobie z wyjątkami.  Niektóre części kodu mogłyby być bardziej modułowe.  Funkcja `main()` jest dość duża i mogłaby zostać podzielona na mniejsze funkcje dla lepszej czytelności i testowalności.  Moduł `media_processor` jest dobrze zaprojektowany, ale jego wydajność, szczególnie w przypadku przetwarzania wideo, wymaga dalszej analizy i optymalizacji.  Rozważenie użycia asynchronicznych operacji wewnątrz modułu `media_processor` mogłoby poprawić wydajność.  Dodatkowo, warto rozważyć dodanie testów jednostkowych dla funkcji w module `media_processor`.  W module `media_processor` należy zwrócić uwagę na obsługę błędów - w wielu miejscach użyto tylko `print(f"Error...")`, co nie jest najlepszym rozwiązaniem.  Należy zastąpić to bardziej zaawansowaną obsługą wyjątków.  W szczególności, funkcja `process_video` jest bardzo złożona i mogłaby zostać podzielona na mniejsze, bardziej modułowe funkcje.  Analiza wydajności funkcji `extract_frames` jest kluczowa, ponieważ przetwarzanie wideo może być czasochłonne.  Rozważenie użycia biblioteki `multiprocessing` dla paralelizacji zadań mogłoby poprawić wydajność.  Zależności między funkcjami w `main.py` są jasne, ale niektóre funkcje mogłyby zostać wyodrębnione do osobnych modułów dla lepszej organizacji kodu.  W szczególności, funkcje związane z przetwarzaniem różnych typów plików (PDF, wideo, obrazy) mogłyby zostać przeniesione do osobnych modułów.  Użycie bardziej zaawansowanych bibliotek do przetwarzania obrazu i wideo mogłoby poprawić jakość i wydajność analizy.  Na przykład, zamiast `cv2.Canny` do detekcji krawędzi, można rozważyć użycie bardziej zaawansowanych algorytmów, takich jak detekcja krawędzi Sobela lub Canny z optymalizacją parametrów.  Aktualizacja bibliotek zewnętrznych do najnowszych wersji może również poprawić stabilność i wydajność.  Algorytm detekcji typu ujęcia w funkcji `detect_shot_type` mógłby zostać ulepszony poprzez zastosowanie bardziej zaawansowanych metod detekcji obiektów, takich jak detekcja głębokiego uczenia (np. YOLO, SSD).  Poprawa czytelności kodu poprzez bardziej opisowe nazwy zmiennych i funkcji oraz dodanie komentarzy jest również zalecana.  Modularizacja funkcji w `media_processor` (np. wyodrębnienie analizy klatek do osobnego modułu) poprawiłaby czytelność i testowalność kodu.  Zastosowanie wzorców projektowych, takich jak strategia lub dekorator, mogłoby również poprawić strukturę kodu i ułatwić jego rozszerzanie.  Silne sprzężenie między modułem `media_processor` a `main` utrudnia testowanie i konserwację.  Rozważenie dalszej modularizacji kodu, aby zmniejszyć sprzężenie między tymi modułami.  W szczególności, funkcje związane z przetwarzaniem wideo mogłyby zostać przeniesione do osobnego modułu, co poprawiłoby modularność i ułatwiłoby testowanie.  Dodatkowo, warto rozważyć użycie biblioteki `tqdm` dla wizualizacji postępu przetwarzania.

- **Sugestie refaktoryzacji:**

  - Dodanie bardziej szczegółowej obsługi błędów w funkcjach `crawl_website`, `convert_pdf_to_text`, `process_pdfs`, `process_media_file` i `query_production_docs`.  Użycie wyjątków i spójnego sposobu raportowania błędów.
  - Podzielenie funkcji `main()` na mniejsze, bardziej modułowe funkcje (np. funkcje dla każdego etapu przetwarzania: pobieranie, parsowanie, analiza, generowanie podsumowania).
  - Wyodrębnienie logiki pobierania plików do osobnego modułu.
  - Wyodrębnienie logiki generowania podsumowań do osobnego modułu.
  - Dodanie testów jednostkowych dla każdej funkcji.
  - Użycie bardziej zaawansowanych technik obsługi asynchroniczności (np. `aiohttp` zamiast `requests`).
  - Analiza modułu `media_processor` pod kątem optymalizacji wydajności i możliwości ulepszeń algorytmów przetwarzania obrazu i wideo.  Rozważenie użycia bardziej zaawansowanych bibliotek do przetwarzania obrazu i wideo, a także zastosowanie asynchronicznych operacji dla poprawy wydajności.  Dodanie testów jednostkowych dla funkcji w module `media_processor`.  Zastąpienie `print(f"Error...")` bardziej zaawansowaną obsługą wyjątków.  Podział funkcji `process_video` na mniejsze, bardziej modułowe funkcje.  Optymalizacja funkcji `extract_frames` pod kątem wydajności, np. poprzez paralelizację przetwarzania klatek.  Modularizacja kodu dla lepszej organizacji i testowalności.  Rozważenie użycia biblioteki `concurrent.futures` dla paralelizacji zadań.  Rozważenie użycia bibliotek takich jak `scikit-image` dla bardziej zaawansowanych operacji na obrazach.  Aktualizacja bibliotek zewnętrznych do najnowszych wersji.  Zastąpienie detekcji twarzy w funkcji `detect_shot_type` bardziej zaawansowaną metodą, np. wykorzystującą głębokie uczenie.  Wyodrębnienie funkcji analizy klatek do osobnego modułu.  Poprawa czytelności kodu poprzez bardziej opisowe nazwy zmiennych i funkcji oraz dodanie komentarzy.  Zastosowanie wzorców projektowych, takich jak strategia lub dekorator, mogłoby również poprawić strukturę kodu i ułatwić jego rozszerzanie.  Zmniejszenie sprzężenia między modułem `media_processor` a `main` poprzez lepszą modularizację.  Dodanie obsługi postępu przetwarzania za pomocą biblioteki `tqdm`.  Dodanie dokumentacji do każdej funkcji w module `media_processor`.